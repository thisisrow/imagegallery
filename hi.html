<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Draggable Image Grid</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom cursor styles */
        .cursor-grab {
            cursor: grab;
        }
        .cursor-grabbing {
            cursor: grabbing;
        }
        /* Hint for the browser to optimize transform changes */
        #image-grid {
            will-change: transform;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 flex flex-col items-center justify-center h-screen m-0 p-0 overflow-hidden">

    <div class="absolute top-0 left-0 p-6 text-center w-full z-10 bg-gradient-to-b from-gray-900 to-transparent">
        <h1 class="text-3xl font-bold text-white">Draggable Image Grid</h1>
        <p class="text-gray-400 mt-2">Click and drag anywhere to move the grid. Works with touch, too!</p>
    </div>

    <!-- The viewport container. overflow-hidden is crucial to hide the parts of the grid that move outside the screen. -->
    <div id="viewport" class="relative w-full h-full overflow-hidden cursor-grab z-0">
        
        <!-- The grid container that will be moved. It's larger than the viewport to allow for dragging. -->
        <div id="image-grid" class="absolute grid grid-cols-3 sm:grid-cols-4 md:grid-cols-6 lg:grid-cols-8 gap-4 p-4 select-none" style="left: -25%; top: -25%; width: 150%; height: 150%;">
            <!-- We disable pointer events on the images themselves to prevent the default browser image drag behavior -->
            <script>
                // A simple script to generate the image grid dynamically
                const imageGrid = document.getElementById('image-grid');
                const aspectRatios = ['4/5', '1/1', '16/9', '2/3'];
                const colors = ['4A5568', 'A0AEC0', 'FBBF24', 'F87171', '60A5FA', '34D399'];
                for (let i = 0; i < 120; i++) {
                    const ratio = aspectRatios[i % aspectRatios.length];
                    const color = colors[i % colors.length];
                    const [w, h] = ratio.split('/').map(Number);
                    
                    const item = document.createElement('div');
                    item.className = 'bg-gray-800 rounded-lg shadow-lg overflow-hidden transition-transform duration-300 ease-out hover:scale-105';
                    item.style.aspectRatio = ratio;

                    const img = document.createElement('img');
                    img.src = `https://placehold.co/${w*200}x${h*200}/${color}/FFFFFF?text=Image+${i+1}`;
                    img.alt = `Placeholder Image ${i+1}`;
                    img.className = 'w-full h-full object-cover pointer-events-none height-full';
                    img.loading = 'lazy';

                    item.appendChild(img);
                    imageGrid.appendChild(item);
                }
            </script>
        </div>
    </div>

    <script>
        const viewport = document.getElementById('viewport');
        const grid = document.getElementById('image-grid');

        // --- State Variables ---
        let isDown = false;
        let lastX, lastY;
        let currentX = 0, currentY = 0;

        // --- Physics/Inertia Variables ---
        let velocityX = 0, velocityY = 0;
        const friction = 0.92; // How quickly momentum fades (0 to 1). A lower number means more friction.
        const pushStrength = 1.2; // How strongly the drag motion affects velocity.
        let bounds = {};

        // --- Functions ---
        const calculateBounds = () => {
            const overscrollX = grid.offsetWidth - viewport.clientWidth;
            const overscrollY = grid.offsetHeight - viewport.clientHeight;
            bounds = {
                minX: -(overscrollX / 2),
                maxX: overscrollX / 2,
                minY: -(overscrollY / 2),
                maxY: overscrollY / 2,
            };
        };

        // --- Event Handlers ---
        const startDrag = (e) => {
            isDown = true;
            viewport.classList.add('cursor-grabbing');
            
            // Record the starting point of the drag to calculate movement delta
            lastX = e.pageX || e.touches[0].pageX;
            lastY = e.pageY || e.touches[0].pageY;
        };

        const endDrag = () => {
            isDown = false;
            viewport.classList.remove('cursor-grabbing');
        };

        const drag = (e) => {
            if (!isDown) return;
            e.preventDefault();

            // Get current mouse/touch position
            const x = e.pageX || e.touches[0].pageX;
            const y = e.pageY || e.touches[0].pageY;

            // Calculate the "push" vector from the last mouse position
            const pushX = x - lastX;
            const pushY = y - lastY;
            
            // Add this push to the velocity, amplifying it slightly for a better feel
            velocityX += pushX * pushStrength;
            velocityY += pushY * pushStrength;
            
            // Update last mouse position for the next frame
            lastX = x;
            lastY = y;
        };

        // --- Main Animation Loop ---
        // This single loop handles all movement, both during drag and for inertia.
        const animationLoop = () => {
            // Update position based on current velocity
            currentX += velocityX;
            currentY += velocityY;
            
            // Clamp position to bounds and stop velocity when hitting an edge
            if (currentX > bounds.maxX) {
                currentX = bounds.maxX;
                velocityX = 0;
            } else if (currentX < bounds.minX) {
                currentX = bounds.minX;
                velocityX = 0;
            }

            if (currentY > bounds.maxY) {
                currentY = bounds.maxY;
                velocityY = 0;
            } else if (currentY < bounds.minY) {
                currentY = bounds.minY;
                velocityY = 0;
            }

            // Apply friction to slow down constantly
            velocityX *= friction;
            velocityY *= friction;

            // Stop tiny movements to prevent the loop from running forever on negligible values
            if (Math.abs(velocityX) < 0.01) velocityX = 0;
            if (Math.abs(velocityY) < 0.01) velocityY = 0;

            // Apply the transformation using translate3d for better performance
            grid.style.transform = `translate3d(${currentX}px, ${currentY}px, 0)`;

            // Continue the loop on the next available frame
            requestAnimationFrame(animationLoop);
        };

        // --- Attach Event Listeners ---
        
        // Mouse events
        viewport.addEventListener('mousedown', startDrag);
        // Listen on the window to catch the mouseup event even if the cursor leaves the viewport
        window.addEventListener('mouseup', endDrag);
        viewport.addEventListener('mouseleave', endDrag);
        viewport.addEventListener('mousemove', drag);

        // Touch events for mobile
        viewport.addEventListener('touchstart', (e) => {
            // Prevent the browser's default scroll/zoom behavior while dragging
            e.preventDefault();
            startDrag(e);
        }, { passive: false });
        
        // Listen on the window for touchend as well
        window.addEventListener('touchend', endDrag);
        viewport.addEventListener('touchmove', (e) => {
            e.preventDefault();
            drag(e);
        }, { passive: false });

        // Start the main animation loop right away
        calculateBounds();
        animationLoop();

        // Recalculate bounds on window resize for responsiveness
        window.addEventListener('resize', calculateBounds);
    </script>

</body>
</html>

